#' Metaheatmaps of the two extremities of the reads.
#'
#' This function generates four metaheatmaps displaying the abundance of the 5'
#' and 3' extremity of reads mapping around the start and the stop codon of
#' annotated CDSs, stratified by their length.
#'
#' @param data Either list of data tables or GRangesList object from
#'   \code{\link{bamtolist}}, \code{\link{bedtolist}},
#'   \code{\link{length_filter}} or \code{\link{psite_info}}.
#' @param annotation Data table as generated by \code{\link{create_annotation}}.
#' @param sample Character string specifying the name of the sample of interest.
#' @param transcripts Character string vector listing the name of transcripts to
#'   be included in the analysis. Default is NULL i.e. all transcripts are used.
#'   Please note: transcripts with either 5' UTR, coding sequence or 3' UTR
#'   shorter than \code{utr5l}, \eqn{2*}\code{cdsl} and \code{utr3l},
#'   respectively, are automatically discarded.
#' @param cl Integer value in [1,100] specifying a confidence level for
#'   restricting the plot to a sub-range of read lengths. The new range is
#'   associated to the most abundant populations of reads accounting for the cl%
#'   of the sample. Default is 95.
#' @param utr5l Positive integer specifying the length (in nucleotides) of the
#'   5' UTR region flanking the start codon to be considered in the analysis.
#'   Default is 50.
#' @param cdsl Positive integer specifying the length (in nucleotides) of the
#'   CDS regions flanking both the start and stop codon to be considered in the
#'   analysis. Default is 50.
#' @param utr3l Positive integer specifying the length (in nucleotides) of the
#'   3' UTR region flanking the stop codon to be considered in the analysis.
#'   Default is 50.
#' @param colour Character string specifying the colour of the plot. The colour
#'   scheme is as follow: tiles corresponding to the lowest signal are always
#'   white, tiles corresponding to the highest signal are of the specified
#'   colour and the progression between these two colours follows either linear
#'   or logarithmic gradients (see \code{log_colour}). Default is "black".
#' @param log_colour Logical value whether to use a logarithmic colour scale
#'   (strongly suggested in case of large signal variations). Default is FALSE.
#' @return A list containing a ggplot2 object ("plot") and the data table with
#'   the associated data ("dt").
#' @examples
#' data(reads_list)
#' data(mm81cdna)
#'
#' ## Generate metaheatmaps for all read lengths:
#' heatend_whole <- rends_heat(reads_list, mm81cdna, sample = "Samp1", cl = 100)
#'
#' ## Generate metaheatmaps for a sub-range of read lengths shortening the
#' ## flanking regions around the start and stop codon:
#' heatend_sub95 <- rends_heat(reads_list, mm81cdna, sample = "Samp1", cl = 95,
#' utr5l = 30, cdsl = 40, utr3l = 30)
#' @import data.table
#' @import ggplot2
#' @export
rends_heat <- function(data, annotation, sample, transcripts = NULL, cl = 95, 
                       utr5l = 50, cdsl = 50, utr3l = 50, log_colour = F,
                       colour = "black") {
  temp_dt <- data[[sample]]
  
  if(class(temp_dt)[1] == "GRanges"){
    temp_dt <- as.data.table(temp_dt)[, c("width", "strand") := NULL
                                      ][, seqnames := as.character(seqnames)]
    setnames(temp_dt, c("seqnames", "start", "end"), c("transcript", "end5", "end3"))
  }
  
  temp_dt[, start_dist_end5 := end5 - cds_start
          ][, stop_dist_end5 := end5 - cds_stop
            ][, start_dist_end3 := end3 - cds_start
              ][, stop_dist_end3 := end3 - cds_stop]

  minlen <- ceiling(quantile(temp_dt$length, (1 - cl/100)/2))
  maxlen <- ceiling(quantile(temp_dt$length, 1 - (1 - cl/100)/2))
  
  l_transcripts <- as.character(annotation[l_utr5 >= utr5l & 
                                             l_cds > 2 * (cdsl + 1) &
                                             l_utr3 >= utr3l, transcript])
  
  if (length(transcripts) == 0) {
    c_transcripts <- l_transcripts
  } else {
    c_transcripts <- intersect(l_transcripts, transcripts)
  }
  
  dt <- temp_dt[transcript %in% c_transcripts]
  temp_dt[, c("start_dist_end5", "stop_dist_end5", "start_dist_end3", "stop_dist_end3") := NULL]
  
  # 5' end
  start_sub <- dt[start_dist_end5 %in% seq(-utr5l, cdsl)]
  start_tab <- setkey(start_sub, length, start_dist_end5)[CJ(unique(length), unique(start_dist_end5)), .N, by=.EACHI]
  setnames(start_tab, c("length", "dist", "count"))
  start_tab[, region := "start"]
  stop_sub <- dt[stop_dist_end5 %in% seq(-cdsl, utr3l)]
  stop_tab <- setkey(stop_sub, length, stop_dist_end5)[CJ(unique(length), unique(stop_dist_end5)), .N, by=.EACHI]
  setnames(stop_tab, c("length", "dist", "count"))
  stop_tab[, region := "stop"]
  final_tab5 <- rbind(start_tab, stop_tab)
  final_tab5[, end := "5end"]
  
  # 3' end
  start_sub <- dt[start_dist_end3 %in% seq(-utr5l, cdsl)]
  start_tab <- setkey(start_sub, length, start_dist_end3)[CJ(unique(length), unique(start_dist_end3)), .N, by=.EACHI]
  setnames(start_tab, c("length", "dist", "count"))
  start_tab[, region := "start"]
  stop_sub <- dt[stop_dist_end3 %in% seq(-cdsl, utr3l)]
  stop_tab <- setkey(stop_sub, length, stop_dist_end3)[CJ(unique(length), unique(stop_dist_end3)), .N, by=.EACHI]
  setnames(stop_tab, c("length", "dist", "count"))
  stop_tab[, region := "stop"]
  final_tab3 <- rbind(start_tab, stop_tab)
  final_tab3[, end := "3end"]

  # all
  final_tab <- rbind(final_tab5, final_tab3)
  final_tab[, region := factor(region, levels = c("start", "stop"), labels = c("Distance from start (nt)", "Distance from stop (nt)"))]
  final_tab[, end := factor(end, levels = c("5end", "3end"), labels = c("5' end", "3' end"))]

  # plot
  max<-max(final_tab$count)
  p <- ggplot(final_tab, aes(dist, length)) +
    geom_tile(aes(fill = count)) +
    labs(title = paste(sample, "5' / 3' read end metaheatmaps", sep = " - "), y = "Read length") +
    theme_bw(base_size = 22) +
    theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(), axis.title.x = element_blank()) +
    facet_grid(end ~ region, scales = "free", switch = "x") +
    theme(strip.background = element_blank(), strip.placement = "outside") +
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_y_continuous(limits = c(minlen - 0.5, maxlen + 0.5), breaks = seq(minlen + ((minlen) %% 2), maxlen, by = max(2,floor((maxlen - minlen)/7)))) +
    geom_vline(xintercept = 0, linetype = 2, color = "red")
  
  if (log_colour == F) {
    p <- p +
      scale_fill_gradient("Number\nof read\nextremities\n", low = "white", high = colour, limits = c(0.1, max), breaks = c(0.1, max/2, max), labels = c("0", floor(max/2), floor(max)), na.value = "white")
  } else {
    p <- p +
      scale_fill_gradient("Number\nof read\nextremities\n", low = "white", high = colour, limits = c(0.1, max), breaks = c(0.1, 10^(log10(max)/2 - 0.5), floor(max)), labels = c("0", floor(10^(log10(max)/2 - 0.5)), floor(max)), trans = "log", na.value = "transparent")
  }
  
  output<-list()
  output[["plot"]] <- p
  output[["dt"]] <- final_tab
  return(output)
}
