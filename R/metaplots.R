#' Ribosome occupancy metaprofiles at single-nucleotide resolution.
#'
#' This function generates two metaprofiles displaying the abundance of P-sites
#' around the start and the stop codon of annotated CDSs.
#' 
#' @param data List of data tables from \code{\link{psite_info}}.
#' @param annotation Data table as generated by \code{\link{create_annotation}}.
#' @param sample Either a character string specifying the name of the sample of
#'   interest or a character string vector specifying the name of its
#'   replicates. In the latter case the final metaprofiles are generated by
#'   merging the results for each replicate exploiting the scale factors
#'   specified by \code{scale_factors}.
#' @param scale_factors Named numeric vector the same length as \code{sample}
#'   specifying the scale factors for generating metaprofiles from multiple
#'   replicates (see \code{sample}). Please be careful to name each element of
#'   the vector after the correct corresponding string in \code{sample}. No
#'   specific order is required. Default is NULL i.e. all scale factors are
#'   automatically set to 1.
#' @param length_range Integer or an integer vector specyfying the read
#'   length(s) to be included in the analysis. Default is "all" i.e. all read
#'   lengths are used.
#' @param transcripts Character string vector listing the name of transcripts to
#'   be included in the analysis. Default is NULL i.e. all transcripts are used.
#'   Please note: transcripts with either 5' UTR, coding sequence or 3' UTR
#'   shorter than \code{utr5l}, \eqn{2*}\code{cdsl} and \code{utr3l},
#'   respectively, are automatically discarded.
#' @param utr5l Positive integer specifying the length (in nucleotides) of the
#'   5' UTR region flanking the start codon to be considered in the analysis.
#'   Default is 25.
#' @param cdsl Positive integer specifying the length (in nucleotides) of the
#'   CDS regions flanking both the start and stop codon to be considered in the
#'   analysis. Default is 50.
#' @param utr3l Positive integer specifying the length (in nucleotides) of the
#'   3' UTR region flanking the stop codon to be considered in the analysis.
#'   Default is 25.
#' @param plot_title Character string specifying the title of the plot. If
#'   "auto", the title of the plot reports the sample(s) specified by
#'   \code{sample} as well as the number of transcripts and the read length(s)
#'   employed for generating the metaprofiles. Default is NULL i.e. no title is
#'   displayed.
#' @details The intensity of signal in the metaprofiles corresponds, for each
#'   nucleotide, to the sum of the number of P-sites (defined by their leftmost
#'   position) mapping on that position for all transcripts in one or multiple
#'   replicates.
#' @return A list containing a ggplot2 object ("plot") and the data table with
#'   the associated data ("dt").
#' @examples
#' data(reads_psite_list)
#' data(mm81cdna)
#'
#' ## Generate metaprofiles employing all read lengths:
#' metaprof_whole <- metaprofile_psite(reads_psite_list, mm81cdna, sample = "Samp1")
#' metaprof_whole[["plot"]]
#'
#' ## Generate metaprofiles employing reads of 27, 28 and 29 nucleotides and a
#' ## subset of transcripts (in this example only transcripts with at least one
#' ## P-site mapping on the translation initiation site are kept):
#' sample_name <- "Samp1"
#' sub_reads_psite_list <- reads_psite_list[[sample_name]][psite_from_start == 0]
#' transcript_names <- as.character(sub_reads_psite_list$transcript)
#' metaprof_sub <- metaprofile_psite(reads_psite_list, mm81cdna, sample = sample_name,
#' length_range = 27:29, transcripts = transcript_names)
#' @import data.table
#' @import ggplot2
#' @export
metaprofile_psite <- function(data, annotation, sample, scale_factors = NULL,
                              length_range = "all", transcripts = NULL,
                              utr5l = 25, cdsl = 50, utr3l = 25,
                              plot_title = NULL) {
  
  if(!identical(length_range, "all") & !inherits(length_range, "numeric") & !inherits(length_range, "integer")){
    cat("\n")
    warning("class of length_range is neither numeric nor integer. Set to default \"all\"\n")
    length_range = "all"
  }
  
  if(!identical(length_range, "all")){
    for(samp in sample){
      len_check <- unique(data[[samp]]$length)
      if(sum(length_range %in% len_check) == 0) {
        cat("\n")
        warning(sprintf("\"%s\" doesn't contain any reads of the specified lengths: sample removed\n", samp))
        sample <- sample[sample != samp]
      }
    }
  }

  if(length(sample) == 0){
    cat("\n")
    stop("none of the data tables in sample contains any reads of the specified lengths\n\n")
  }

  if(length(scale_factors) != 0) {
    if(!all(sample %in% names(scale_factors))){
      cat("\n")
      stop("scale factor for one or more replicates is missing\n\n")
    }
  }
  
  l_transcripts <- as.character(annotation[l_utr5 >= utr5l & 
                                             l_cds >= 2 * (cdsl + 1) &
                                             l_utr3 >= utr3l, transcript])
  
  if (length(transcripts) == 0) {
    c_transcripts <- l_transcripts
    ntr <- length(c_transcripts)
  } else {
    c_transcripts <- intersect(l_transcripts, transcripts)
    ntr <- length(transcripts)
  }
  
  length_temp <- vector()

  for (samp in sample) {
    
    dt <- data[[samp]][as.character(transcript) %in% c_transcripts, ]
    
    if (identical(length_range, "all")) {
      start_sub <- dt[psite_from_start %in% seq(-utr5l, cdsl)]
      stop_sub <- dt[psite_from_stop %in% seq(-cdsl, utr3l)]
    } else {
      start_sub <- dt[psite_from_start %in% seq(-utr5l, cdsl) & length %in% length_range]
      stop_sub <- dt[psite_from_stop %in% seq(-cdsl, utr3l) & length %in% length_range]
    }
    
    setkey(start_sub, psite_from_start)
    start_tab <- start_sub[CJ(-utr5l:cdsl), list(reads = .N), by = list(distance = psite_from_start)
                           ][, reg := "start"]
    setkey(stop_sub, psite_from_stop)
    stop_tab <- stop_sub[CJ(-cdsl:utr3l), list(reads = .N), by = list(distance = psite_from_stop)
                           ][, reg := "stop"]
    samp_tab <- rbind(start_tab, stop_tab)
    
    if(length(scale_factors) != 0) {
      samp_tab[, reads := reads * scale_factors[samp]]
    }

    if(exists("final_tab_psm")) {
      final_tab_psm[, reads := reads + samp_tab$reads]
    } else {
      final_tab_psm <- samp_tab
    }
    
    length_temp <- unique(c(length_temp, data[[samp]]$length))
  }
  
  if(!identical(length_range, "all")){
    length_range <- sort(intersect(length_temp, length_range))
  } else {
    length_range <- sort(length_temp)
  }
  
  final_tab_psm[, reg := factor(reg, levels = c("start", "stop"), labels = c("Distance from start (nt)", "Distance from stop (nt)"))]

  linestart <- data.table(reg = rep(c("Distance from start (nt)", "Distance from stop (nt)"), times = c(length(c(rev(seq(-3, -utr5l, -3)), seq(3, cdsl, 3))), length(c(rev(seq(-2, -cdsl, -3)), seq(1, utr3l, 3))))), line = c(rev(seq(-3, -utr5l, -3)), seq(3, cdsl, 3), rev(seq(-2, -cdsl, -3)), seq(1, utr3l, 3)))
  linered <- data.table(reg = c("Distance from start (nt)", "Distance from stop (nt)"), line =c(0, 1))
  
  plot <- ggplot(final_tab_psm, aes(distance, reads)) +
    geom_line(size=1.05, color="gray40") +
    geom_vline(data = linered, aes(xintercept = line), linetype = 1, color = "red") +
    labs(x = "", y = "P-site") +
    theme_bw(base_size = 20) +
    theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank()) +
    facet_grid(. ~ reg, scales = "free", switch = "x") +
    theme(strip.background = element_blank(), strip.placement = "outside") +
    geom_vline(data = linestart, aes(xintercept = line), linetype = 3, color = "gray60")

  if(identical(plot_title, "auto")) {
    
    title1 <- paste0(paste(sample, collapse = "+"), " (", ntr, " tr). Read length: ")
    minlr <- min(length_range)
    maxlr <- max(length_range)

    if(minlr == maxlr) {
      plottitle <- paste0(title1, min(length_range), " nts")
    } else {
      if(identical(length_range, minlr:maxlr) | identical(length_range, seq(minlr, maxlr, 1))){
        plottitle <- paste0(title1, minlr, "-", maxlr, " nts")
      } else {
        nextl <- sort(length_range[c(which(diff(length_range) != 1), which(diff(length_range) != 1) + 1)])
        sep <- ifelse(nextl %in% length_range[which(diff(length_range) != 1)], ", ", "-")[-length(nextl)]
        if(1 %in% which(diff(length_range) == 1)){
          nextl <- c( length_range[1], nextl)
          sep <- c("-", sep)
        }
        if((length(length_range) - 1) %in% which(diff(length_range) == 1)){
          nextl <- c(nextl, length_range[length(length_range)])
          sep <- c(sep, "-")
        }
        sep <- c(sep, "")
        plottitle <- paste0(title1, paste0(nextl, sep, collapse = ""), " nts")
      }
    }
    plot <- plot +
      labs(title = plottitle) +
      theme(plot.title = element_text(hjust = 0.5))
  } else {
    if(length(plot_title) != 0){
      plot <- plot +
        labs(title = plot_title) + 
        theme(plot.title = element_text(hjust = 0.5))
    }
  }
  
  output <- list()
  output[["plot"]] <- plot
  output[["dt"]] <- final_tab_psm
  return(output)
}

#' Ribosome occupancy metaheatmaps at single-nucleotide resolution.
#'
#' This function generates two heatmap-like metaprofiles (metaheatmaps)
#' displaying the abundance of P-sites around the start and the stop codon of
#' annotated CDSs. It works similarly to \code{\link{metaprofile_psite}} but the
#' intensity of signal is represented by a continuous color scale rather than by
#' the height of a line chart. This graphical output is a good option to
#' visualize several profiles at once and compare results obtained with
#' different read lengths or in multiple conditions.
#'
#' @param data List of data tables from \code{\link{psite_info}}.
#' @param annotation Data table as generated by \code{\link{create_annotation}}.
#' @param sample List of either character strings specifying the name of the
#'   sample(s) of interest or character string vectors specifying the name of
#'   their replicates. In the latter case the final metaheatmaps for each
#'   element of the list are generated by merging the results for the
#'   corresponding replicates exploiting the scale factors specified by
#'   \code{scale_factors}. The row(s) of the final plot are labelled according
#'   to the name of the elements of the list.
#' @param scale_factors Named numeric vector specifying the scale factors for
#'   generating metaprofiles from multiple replicates (see \code{sample}). Scale
#'   factors can be defined for a subset of list elements of \code{sample} i.e.
#'   for all replicates of selected samples. If so, the remaining scale factors
#'   are set automatically to 1. Please be careful to name each element of the
#'   vector after the correct corresponding string in \code{sample}. No specific
#'   order is required. Default is NULL i.e. all scale factors are automatically
#'   set to 1.
#' @param length_range Integer or an integer vector specyfying the read
#'   length(s) to be included in the analysis. Default is "all" i.e. all read
#'   lengths are used.
#' @param transcripts Character string vector listing the name of transcripts to
#'   be included in the analysis. Default is NULL i.e. all transcripts are used.
#'   Please note: transcripts with either 5' UTR, coding sequence or 3' UTR
#'   shorter than \code{utr5l}, \eqn{2*}\code{cdsl} and \code{utr3l},
#'   respectively, are automatically discarded.
#' @param utr5l Positive integer specifying the length (in nucleotides) of the
#'   5' UTR region flanking the start codon to be considered in the analysis.
#'   Default is 25.
#' @param cdsl Positive integer specifying the length (in nucleotides) of the
#'   CDS regions flanking both the start and stop codon to be considered in the
#'   analysis. Default is 50.
#' @param utr3l Positive integer specifying the length (in nucleotides) of the
#'   3' UTR region flanking the stop codon to be considered in the analysis.
#'   Default is 25.
#' @param colour Character string specifying the colour of the plot. The colour
#'   scheme is as follow: tiles corresponding to the lowest signal are always
#'   white, tiles corresponding to the highest signal are of the specified
#'   colour and the progression between these two colours follows either linear
#'   or logarithmic gradients (see \code{log_colour}). Default is "black".
#' @param log_colour Logical value whether to use a logarithmic colour scale
#'   (strongly suggested in case of large signal variations). Default is FALSE.
#' @param plot_title Character string specifying the title of the plot. If
#'   "auto", the title of the plot reports the number of transcripts and the
#'   read length(s) employed for generating the metaprofiles. Default is NULL
#'   i.e. no title is displayed.
#' @details The intensity of signal in the metaprofiles corresponds, for each
#'   nucleotide, to the sum of the number of P-sites (defined by their leftmost
#'   position) mapping on that position for all transcripts in one or multiple
#'   replicates.
#' @return A list containing a ggplot2 object ("plot") and the data table
#'   with the associated data ("dt").
#' @examples
#' data(reads_psite_list)
#'
#' ## Generate metaheatmaps employing all read lengths:
#' metaheat_whole <- metaheatmap_psite(reads_psite_list, mm81cdna, sample = list("Whole"=c("Samp1")))
#'
#' ## Generate metaprofiles employing reads of 27, 28 and 29 nucleotides and a
#' ## subset of transcripts (in this example only transcripts with at least one
#' ## P-site mapping on the translation initiation site are kept):
#' sample_name <- "Samp1"
#' sub_reads_psite_list <- subset(reads_psite_list[[sample_name]], psite_from_start == 0)
#' transcript_names <- as.character(sub_reads_psite_list$transcript)
#' metaheat_sub <- metaheatmap_psite(reads_psite_list, mm81cdna, sample = list("sub"=sample_name),
#' length_range = 27:29, transcripts = transcript_names, plot_title = "auto")
#'
#' ## Generate two sets of metaheatmaps, displayed in the same plot. In this
#' ## example one set of metaheatmaps is based on all read lengths while the
#' ## other one is generated employing only reads of 28 nucleotides:
#' sample_name <- "Samp1"
#' metaheat_df <- list()
#' metaheat_df[["subsample_28nt"]] <- subset(reads_psite_list[[sample_name]], length == 28)
#' metaheat_df[["whole_sample"]] <- reads_psite_list[[sample_name]]
#' names_list <- list("Only_28" = c("subsample_28nt"), "All" = c("whole_sample"))
#' metaheat_comparison <- metaheatmap_psite(metaheat_df, mm81cdna, sample = names_list)
#' @import data.table
#' @import ggplot2
#' @export
metaheatmap_psite <- function(data, annotation, sample, scale_factors = NULL,
                              length_range = "all", transcripts = NULL,
                              utr5l = 25, cdsl = 50, utr3l = 25, log_colour = F,
                              colour = "black", plot_title = NULL) {
  
  if(!identical(length_range, "all") & !inherits(length_range, "numeric") & !inherits(length_range, "integer")){
    cat("\n")
    warning("class of length_range is neither numeric nor integer. Set to default \"all\"\n")
    length_range = "all"
  }
  
  if(!identical(length_range, "all")){
    for(sampgroup in names(sample)){
      for(samp in sample[[sampgroup]]){
        len_check <- unique(data[[samp]]$length)
        if(sum(length_range %in% len_check) == 0) {
          cat("\n")
          warning(sprintf("\"%s\" doesn't contain any reads of the specified lengths: sample removed\n", samp))
          sample[[sampgroup]] <- sample[[sampgroup]][sample[[sampgroup]] != samp]
        }
      }
      if(length(sample[[sampgroup]]) == 0) {
        cat("\n")
        warning(sprintf("none of the data tables in \"%s\" contain reads of the specified lengths: group of samples removed \n", sampgroup))
        sample[[sampgroup]] <- NULL
      }
    }
  }
  
  if(length(sample) == 0){
    cat("\n")
    stop("none of the data tables in sample contains any reads of the specified lengths\n\n")
  }
  
  if(length(scale_factors) != 0) {
    for(sampgroup in names(sample)){
      if(!all(sample[[sampgroup]] %in% names(scale_factors)) & !all(!(sample[[sampgroup]] %in% names(scale_factors)))){
        cat("\n")
        stop(sprintf("scale factor for one or more replicates of \"%s\" is missing\n\n", sampgroup))
      }
    }
  }
  
  l_transcripts <- as.character(annotation[l_utr5 >= utr5l & 
                                             l_cds >= 2 * (cdsl + 1) &
                                             l_utr3 >= utr3l, transcript])
  
  if (length(transcripts) == 0) {
    c_transcripts <- l_transcripts
    ntr <- length(c_transcripts)
  } else {
    c_transcripts <- intersect(l_transcripts, transcripts)
    ntr <- length(transcripts)
  }
  
  length_temp <- vector()
  
  for(sampgroup in names(sample)){
    for(samp in sample[[sampgroup]]) {
      
      dt <- data[[samp]][as.character(transcript) %in% c_transcripts]
      
      if (identical(length_range, "all")) {
        start_sub <- dt[psite_from_start %in% seq(-utr5l, cdsl)]
        stop_sub <- dt[psite_from_stop %in% seq(-cdsl, utr3l)]
      } else {
        start_sub <- dt[psite_from_start %in% seq(-utr5l, cdsl) & length %in% length_range]
        stop_sub <- dt[psite_from_stop %in% seq(-cdsl, utr3l) & length %in% length_range]
      }
      
      setkey(start_sub, psite_from_start)
      start_tab <- start_sub[CJ(-utr5l:cdsl), list(reads = .N), by = list(distance = psite_from_start)
                             ][, reg := "start"]
      setkey(stop_sub, psite_from_stop)
      stop_tab <- stop_sub[CJ(-cdsl:utr3l), list(reads = .N), by = list(distance = psite_from_stop)
                           ][, reg := "stop"]
      samp_tab <- rbind(start_tab, stop_tab)
      
      if(samp %in% names(scale_factors)) {
        samp_tab[, reads := reads * scale_factors[samp]]
      }
      
      if(exists("temp_tab_heatmap")) {
        temp_tab_heatmap[, reads := reads + samp_tab$reads]
      } else {
        temp_tab_heatmap <- samp_tab
      }
      temp_tab_heatmap[, sample := sampgroup]
      
      length_temp <- unique(c(length_temp, data[[samp]]$length))
    }
    
    if(exists("final_tab_heatmap")) {
      final_tab_heatmap <- rbind(final_tab_heatmap, temp_tab_heatmap)
    } else {
      final_tab_heatmap <- temp_tab_heatmap
    }
    rm(temp_tab_heatmap)
  }
  
  if(!identical(length_range, "all")){
    length_range <- sort(intersect(length_temp, length_range))
  } else {
    length_range <- sort(length_temp)
  }
  
  final_tab_heatmap[, reg := factor(reg, levels = c("start", "stop"), labels = c("Distance from start (nt)", "Distance from stop (nt)"))
                    ][, sample := factor(sample, levels = rev(unique(final_tab_heatmap$sample)))]
  
  linestart <- data.frame(reg = rep(c("Distance from start (nt)", "Distance from stop (nt)"), times = c(length(c(rev(seq(-3, -utr5l, -3)), seq(3, cdsl, 3))), length(c(rev(seq(-2, -cdsl, -3)), seq(1, utr3l, 3))))), line = c(rev(seq(-3, -utr5l, -3)), seq(3, cdsl, 3), rev(seq(-2, -cdsl, -3)), seq(1, utr3l, 3)))
  linered <- data.frame(reg = c("Distance from start (nt)", "Distance from stop (nt)"), line =c(0, 1))
  
  max <- max(final_tab_heatmap$reads)
  
  plot <- ggplot(final_tab_heatmap, aes(as.numeric(as.character(distance)), sample)) +
    geom_vline(data = linestart, aes(xintercept = line), linetype = 3, color = "gray60") +
    geom_vline(data = linered, aes(xintercept = line), linetype = 1, color = "red") +
    geom_tile(aes(fill = reads), height = 0.7) +
    labs(x = "", y = "", title = plot_title) +
    theme_bw(base_size = 20) +
    theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), strip.placement = "outside") +
    facet_grid(. ~ reg, scales = "free", switch = "x") +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(strip.background = element_blank())
  
  if(log_colour == F) {
    plot <- plot +
      scale_fill_gradient("P-site signal\n", low = "white", high = colour, limits = c(0.1, max), breaks = c(0.1, max/2, max), labels = c("0", floor(max/2), floor(max)), na.value = "white")
  } else {
    plot <- plot +
      scale_fill_gradient("P-site signal\n", low = "white", high = colour, limits = c(0.1, max), breaks = c(0.1, 10^(log10(max)/2 - 0.5), floor(max)), labels = c("0", floor(10^(log10(max)/2 - 0.5)), floor(max)), trans = "log", na.value = "transparent")
  }
  
  if(identical(plot_title, "auto")) {
    
    title1 <- paste0(ntr, " tr. Read length: ")
    minlr <- min(length_range)
    maxlr <- max(length_range)
    
    if(minlr == maxlr) {
      plottitle <- paste0(title1, min(length_range), " nts")
    } else {
      if(identical(length_range, minlr:maxlr) | identical(length_range, seq(minlr, maxlr, 1))){
        plottitle <- paste0(title1, minlr, "-", maxlr, " nts")
      } else {
        nextl <- sort(length_range[c(which(diff(length_range) != 1), which(diff(length_range) != 1) + 1)])
        sep <- ifelse(nextl %in% length_range[which(diff(length_range) != 1)], ", ", "-")[-length(nextl)]
        if(1 %in% which(diff(length_range) == 1)){
          nextl <- c( length_range[1], nextl)
          sep <- c("-", sep)
        }
        if((length(length_range) - 1) %in% which(diff(length_range) == 1)){
          nextl <- c(nextl, length_range[length(length_range)])
          sep <- c(sep, "-")
        }
        sep <- c(sep, "")
        plottitle <- paste0(title1, paste0(nextl, sep, collapse = ""), " nts")
      }
    }
    plot <- plot +
      labs(title = plottitle) +
      theme(plot.title = element_text(hjust = 0.5))
  } else {
    if(length(plot_title) != 0){
      plot <- plot +
        labs(title = plot_title) + 
        theme(plot.title = element_text(hjust = 0.5))
    }
  }
  
  output <- list()
  output[["plot"]] <- plot
  output[["dt"]] <- final_tab_heatmap
  return(output)
}
