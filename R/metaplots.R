#' Ribosome occupancy metaprofiles at single-nucleotide resolution.
#'
#' This function generates metaprofiles displaying the abundance of P-sites
#' around the start and the stop codon of annotated CDSs. For one sample the
#' intensity of the signal in the metaprofiles corresponds, for each nucleotide,
#' to the sum of the number of P-sites (defined by their leftmost position)
#' mapping on that position for all transcripts. Multiple samples can be handled
#' in several ways.
#' 
#' @param data List of data tables from \code{\link{psite_info}}.
#' @param annotation Data table as generated by \code{\link{create_annotation}}.
#' @param sample Either character string or character string vector specifying
#'   the name of the sample(s) of interest. A named list of two or more
#'   character strings and/or character string vectors can be provided. In this
#'   case, each element of the list should include the name of the replicate(s)
#'   of the samples of interest and the name assigned to the elements of the
#'   list are displayed in the plot. Multiple replicates specified in character
#'   string vectors are handled according to \code{multisample}.
#' @param multisamples Either "separated", "average" or "sum". It specifies how
#'   to handle multiple samples and replicates. If "saparated", one metaprofile
#'   for each sample included in \code{sample} is returned as an independent
#'   ggplot object. If "average" or "sum" i) one metaprofiles is returned if
#'   \code{sample} is a character string vector or ii) one metaprofiles is built
#'   for each element of \code{sample} when it is a list. If "average", the
#'   metaprofiles display for each nucleotide the mean signal and the
#'   corresponding standard error computed among the replicates. If "sum",
#'   the metaprofiles display for each nucleotide the sum of the signal of the
#'   replicates. In both cases a single ggplot object is returned, where
#'   multiple metaprofiles are organized and displayed according to
#'   \code{plot_style}. Default is "separated".
#' @param plot_style Either "split", "ovelaid" or "mirrored". It specifies how
#'   to organize and display multiple metaprofiles. If "split", the metaprofiles
#'   are placed one below the other, in independent boxes. If "overlaid", all
#'   metaprofiles are superimposed. If "mirrored" \code{sample} must be a list
#'   of exactly two elements and the two metaprofiles are mirrored along the x
#'   axis. Default is "split".
#' @param scale_factors Named numeric vector the same length as \code{sample}
#'   specifying the scale factors for generating metaprofiles from multiple
#'   replicates (see \code{sample}). Please be careful to name each element of
#'   the vector after the correct corresponding string in \code{sample}. No
#'   specific order is required. When \code{frequency} is TRUE, this parameter
#'   is not considered. Default is NULL i.e. all scale factors are automatically
#'   set to 1.
#' @param length_range Integer or integer vector specyfying the read
#'   length(s) to be included in the analysis. Default is "all" i.e. all read
#'   lengths are used.
#' @param transcripts Character string vector listing the name of transcripts to
#'   be included in the analysis. Default is NULL i.e. all transcripts are used.
#'   Please note: transcripts with either 5' UTR, coding sequence or 3' UTR
#'   shorter than \code{utr5l}, \eqn{2*}\code{cdsl} and \code{utr3l},
#'   respectively, are automatically discarded.
#' @param frequency Logical value whether to normalize the metaprofile(s) such
#'   that the area under the curve(s) is 1. If TRUE and \code{multisamples} is
#'   set to "average" or "sum", the normalization is performed before combining
#'   the signal from multiple samples. Default is FALSE.
#' @param utr5l Positive integer specifying the length (in nucleotides) of the
#'   5' UTR region flanking the start codon to be considered in the analysis.
#'   Default is 25.
#' @param cdsl Positive integer specifying the length (in nucleotides) of the
#'   CDS regions flanking both the start and stop codon to be considered in the
#'   analysis. Default is 50.
#' @param utr3l Positive integer specifying the length (in nucleotides) of the
#'   3' UTR region flanking the stop codon to be considered in the analysis.
#'   Default is 25.
#' @param colour Character string or character string vector specifying the
#'   colour of the metaprofile(s). If \code{sample} is a list of multiple
#'   elements and \code{multisamples} is set to "average" or "sum", a colour for
#'   each element of the list is required. If this parameter is not specified
#'   the R default palette is employed. Default is NULL.
#' @param plot_title Character string specifying the title of the plot. It can
#'   be any string provided by the user or "sample", "transcript" and
#'   "length_range" for automatically displaying the name of the sample(s)
#'   specified by \code{sample}, the number of transcripts and the most frequent
#'   read lengths (i.e. associated to 90% of the signal) employed for generating
#'   the metaprofiles, respectively. A combination of the three strings,
#'   dot-separated, can be used for displaying multiple information. For
#'   example, specifying "sample.length_range" the title reports both the name
#'   of the sample(s) and the read length(s). Default is NULL i.e. no title is
#'   displayed.
#' @return A list containing one or more ggplot2 object(s) and the data table
#'   with the associated data ("dt").
#' @examples
#' ## data(reads_list)
#' ## data(mm81cdna)
#' ##
#' ## ## compute and add p-site datails
#' ## psite_offset <- psite(reads_list, flanking = 6, extremity = "auto")
#' ## reads_psite_list <- psite_info(reads_list, psite_offset)
#' ##
#' ## ## Generate metaprofiles employing all read lengths:
#' ## metaprof_whole <- metaprofile_psite(reads_psite_list, mm81cdna,
#' ##                                     sample = "Samp1")
#' ## metaprof_whole[["plot_Samp1"]]
#' ## 
#' ## ## Generate metaprofiles employing reads of 27, 28 and 29 nucleotides and
#' ## ## a subset of transcripts (in this example only transcripts with at least
#' ## ## one P-site mapping on the translation initiation site are kept):
#' ## sample_name <- "Samp1"
#' ## sub_reads_psite_list <- reads_psite_list[[sample_name]][psite_from_start == 0]
#' ## transcript_names <- as.character(sub_reads_psite_list$transcript)
#' ## metaprof_sub <- metaprofile_psite(reads_psite_list, mm81cdna,
#' ##                                   sample = sample_name,
#' ##                                   length_range = 27:29,
#' ##                                   transcripts = transcript_names)
#' @import data.table
#' @import ggplot2
#' @export
metaprofile_psite <- function(data, annotation, sample, multisamples = "separated",
                              plot_style = "split", scale_factors = NULL,
                              length_range = "all", transcripts = NULL,
                              frequency = FALSE, utr5l = 25, cdsl = 50, utr3l = 25,
                              colour = NULL, plot_title = NULL) {
  
  check_sample <- setdiff(unlist(sample), names(data))
  if(length(check_sample) != 0){
    cat("\n")
    stop(sprintf("incorrect sample name(s): \"%s\" not found\n\n",
                 paste(check_sample, collapse = ", ")))
  }
  
  if(length(scale_factors) != 0) {
    if(!all(as.character(unlist(sample)) %in% names(scale_factors))){
      cat("\n")
      stop("scale factor for one or more replicates is missing\n\n")
    }
  }
  
  if(!identical(length_range, "all") & !inherits(length_range, "numeric") & !inherits(length_range, "integer")){
    cat("\n")
    warning("class of length_range is neither numeric nor integer. It is set to \"all\"\n", call. = FALSE)
    length_range = "all"
  }
  
  if(!identical(length_range, "all")){
    if(is.list(sample)){
      for(sampgroup in names(sample)){
        for(samp in sample[[sampgroup]]){
          len_check <- unique(data[[samp]]$length)
          if(!(any(length_range %in% len_check))) {
            cat("\n")
            warning(sprintf("\"%s\" doesn't contain any reads of the specified lengths: sample removed\n", samp), call. = FALSE)
            sample[[sampgroup]] <- sample[[sampgroup]][sample[[sampgroup]] != samp]
          }
        }
        if(length(sample[[sampgroup]]) == 0) {
          cat("\n")
          warning(sprintf("none of the data tables in \"%s\" contain reads of the specified lengths: group of samples removed \n", sampgroup), call. = FALSE)
          sample[[sampgroup]] <- NULL
        }
      }
    } else {
      for(samp in sample){
        len_check <- unique(data[[samp]]$length)
        if(!(any(length_range %in% len_check))) {
          cat("\n")
          warning(sprintf("\"%s\" doesn't contain any reads of the specified lengths: sample removed\n", samp), call. = FALSE)
          sample <- sample[sample != samp]
        }
      }
    }
  }
  
  if(length(sample) == 0){
    cat("\n")
    stop("at least one sample name must be spcified\n\n")
  }
  
  if(multisamples == "separated" & is.list(sample)) {
    cat("\n")
    warning("parameter multisamples is set to \"separated\" but a list of samples is provided:\nparameter sample will be unlisted and coerced to character string\n", call. = FALSE)
    sample <- as.character(unlist(sample))
  }
  
  if(length(plot_title) != 0){
    plot_title_v <- unlist(tstrsplit(plot_title, ".", fixed = TRUE))
    if(plot_title %like% "sample" & is.list(sample) & length(sample) > 1) {
      cat("\n")
      warning("parameter sample is a list of dimension > 2: plot title won't contain sample names\n", call. = FALSE)
      plot_title_v <- plot_title_v[plot_title_v != "sample"]
      if(length(plot_title_v) == 0){
        plot_title <- NULL
      }
    }
  }
  
  if(is.list(sample) & length(sample) > 2 & plot_style == "mirrored") {
    cat("\n")
    warning("parameter sample is a list of dimension > 2.\nparameter plot_style is set to \"split\"\n", call. = FALSE)
    plot_style == "split"
  }
  
  if(frequency == TRUE & length(scale_factors) != 0){
    cat("\n")
    warning("parameter scale_factors is specified but frequency = TRUE: scale_factors won't be considered\n", call. = FALSE)
  }
  
  if(!(multisamples %in% c("separated", "average", "sum"))){
    cat("\n")
    warning("parameter multisamples must be either  \"separated\", \"average\" or \"sum\"\nit is set to \"separated\"\n", call. = FALSE)
    multisamples = "separated"
  }
  
  if(multisamples != "separated" & 
     !(plot_style %in% c("mirrored", "overlaid", "split"))){
    cat("\n")
    warning("parameter plot_style must be either \"split\", \"mirrored\" or \"overlaid\"\nit is set to \"split\"\n", call. = FALSE)
    plot_style = "split"
  }
  
  if(multisamples %in% c("average", "sum") & ((is.list(sample) & length(sample) == 1) |
                                  (is.character(sample) & length(sample) > 1))){
    plot_style <- "overlaid"
  } 
  
  if(multisamples %in% c("average", "sum") & ((is.character(sample) & length(sample) == 1) |
                                              (is.list(sample) & length(as.character(unlist(sample))) == 1))){
    cat("\n")
    warning("parameter multisamples is set to either \"average\" or \"sum\" but only one sample is provided\nparameter multisample will be set to \"separated\"", call. = FALSE)
    multisamples = "separated"
  }
  
  l_transcripts <- as.character(annotation[l_utr5 >= utr5l & 
                                             l_cds >= 2 * (cdsl + 1) &
                                             l_cds %%3 == 0 &
                                             l_utr3 >= utr3l, transcript])
  
  if (length(transcripts) == 0) {
    c_transcripts <- l_transcripts
    ntr <- length(c_transcripts)
  } else {
    c_transcripts <- intersect(l_transcripts, transcripts)
    ntr <- length(c_transcripts)
  }
  
  if(is.character(sample) | (is.list(sample) & length(sample) == 1)){
    if(is.list(sample) & length(sample) == 1){
      samp_name <- names(sample)
      sample <- as.character(unlist(sample))
      sample_l <- list()
      sample_l[[samp_name]] <- sample
    }
    sample_l <- list("sample_name" = sample)
  } else {
    sample_l <- sample
  }
  
  if(!is.null(colour)){
    if(length(sample_l) == 1){
      colour <- colour[1]
    } else {
      if(length(sample_l) == length(colour)) {
        names(colour) <- names(sample_l)
      } else {
        if(length(sample_l) > length(colour)){
          warning(sprintf("at least %s colours must be specified\nsystem default colours will be used",
                          length(sample_l)), call. = FALSE)
          colour = NULL
        }
      }
    }
  }
  
  length_common <- vector()
  for(samp in as.character(unlist(sample_l))){
    namerep <- samp
    
    dt <- data[[samp]][as.character(transcript) %in% c_transcripts]
    
    if (identical(length_range, "all")) {
      start_sub <- dt[psite_from_start %in% seq(-utr5l, cdsl)]
      stop_sub <- dt[psite_from_stop %in% seq(-cdsl, utr3l)]
    } else {
      start_sub <- dt[psite_from_start %in% seq(-utr5l, cdsl) & length %in% length_range]
      stop_sub <- dt[psite_from_stop %in% seq(-cdsl, utr3l) & length %in% length_range]
    }
    
    setkey(start_sub, psite_from_start)
    start_tab <- start_sub[CJ(-utr5l:cdsl), list(reads = .N), by = .EACHI
                           ][, reg := "start"]
    setnames(start_tab, c("distance", "reads", "reg"))
    setkey(stop_sub, psite_from_stop)
    stop_tab <- stop_sub[CJ(-cdsl:utr3l), list(reads = .N), by = .EACHI
                         ][, reg := "stop"]
    setnames(stop_tab, c("distance", "reads", "reg"))
    samp_tab <- rbind(start_tab, stop_tab)
    
    length_common <- c(length_common, data[[samp]]$length)
    
    if(frequency == TRUE){
      samp_tab[, (samp) := reads / sum(reads)]
    } else {
      if(length(scale_factors) != 0){
        samp_tab[, (samp) := reads * scale_factors[samp]]
      } else {
        samp_tab[, (samp) := reads]
      }
    }
    samp_tab[, reads := NULL]
    
    if(!exists("final_dt")){
      final_dt <- samp_tab
    } else {
      final_dt <- final_dt[, (samp) := samp_tab[, get(samp)]]
    }
  }
  
  lmin <- quantile(length_common, 0.05)
  lmax <- quantile(length_common, 0.95)
  length_common <- unique(length_common[length_common %between% c(lmin, lmax)])
  
  col_plot_sel <- list()
  col_plot_se_sel <- list()
  
  if(length(sample_l) == 1){
    samp_group <- names(sample_l)
    samp <- sample_l[[samp_group]]
    if(length(samp) != 1 & multisamples != "separated"){
      if(multisamples == "average"){
        final_dt[, mean := apply(.SD, 1, mean), .SDcols = samp
                 ][, se := apply(.SD, 1, sd)/sqrt(length(samp)), .SDcols = samp]
        col_plot_sel[[samp_group]] <- "mean"
        col_plot_se_sel[[samp_group]] <- "se"
      } else {
        final_dt[, sum := apply(.SD, 1, sum), .SDcols = samp]
        col_plot_sel[[samp_group]] <- "sum"
      }
    } else {
      col_plot_sel[[samp_group]] <- samp
    }
  } else {
    for(samp_group in names(sample_l)){
      samp <- sample_l[[samp_group]]
      if(length(samp) != 1 & multisamples != "separated"){
        if(multisamples == "average"){
          final_dt[, (paste0("mean_", samp_group)) := apply(.SD, 1, mean), .SDcols = samp
                   ][, (paste0("se_", samp_group)) := apply(.SD, 1, sd)/sqrt(length(samp)), .SDcols = samp]
          col_plot_sel[[samp_group]] <- paste0("mean_", samp_group)
          col_plot_se_sel[[samp_group]] <- paste0("se_", samp_group)
        } else {
          final_dt[, (paste0("sum_", samp_group)) := apply(.SD, 1, sum), .SDcols = samp]
          col_plot_sel[[samp_group]] <-paste0("sum_", samp_group)
        }
      } else {
        col_plot_sel[[samp_group]] <- samp
      }
    }
  }
  
  final_dt[, reg := factor(reg, levels = c("start", "stop"), labels = c("Distance from start (nt)", "Distance from stop (nt)"))]
  
  output <- list()
  output[["dt"]] <- final_dt
  
  lines3nt <- data.table(reg = rep(c("Distance from start (nt)", "Distance from stop (nt)"), times = c(length(seq(3, cdsl, 3)), length(seq(-2, -cdsl, -3)))), line = c(seq(3, cdsl, 3), rev(seq(-2, -cdsl, -3))))
  linered <- data.table(reg = c("Distance from start (nt)", "Distance from stop (nt)"), line =c(0, 1))
  
  if(multisamples != "separated"){
    plot_dt <- copy(final_dt)
    if(plot_style == "mirrored"){
      plot_dt[, (col_plot_sel[[2]]) := - get(col_plot_sel[[2]])]
    }
    col_sel <- c("distance", "reg", as.character(unlist(col_plot_sel)))
    melt_plot_dt <- melt.data.table(plot_dt[, ..col_sel],
                                    id.vars = c("distance", "reg"),
                                    variable.name = "sample",
                                    value.name = "mean"
    )[, sample := factor(sample,
                         levels = as.character(unlist(col_plot_sel)),
                         labels = names(col_plot_sel))]
    
    if(length(col_plot_se_sel) != 0){
      col_sel = c("distance", "reg", as.character(unlist(col_plot_se_sel)))
      melt_plot_se <- melt.data.table(plot_dt[, ..col_sel],
                                      id.vars = c("distance", "reg"),
                                      variable.name = "sample",
                                      value.name = "se"
      )[, sample := factor(sample,
                           levels = as.character(unlist(col_plot_se_sel)),
                           labels = names(col_plot_se_sel))]
      
      melt_plot_dt <- merge.data.table(melt_plot_dt, melt_plot_se,
                                       by = c("distance", "reg", "sample"),
                                       all.x = TRUE, sort = FALSE)
    }
    
    plot <- ggplot(melt_plot_dt, aes(x = distance, y = mean, color = sample)) +
      geom_line(size = 1.50)
    
    if(length(col_plot_se_sel) != 0){
      plot <- plot + geom_ribbon(aes(ymin = mean - se, ymax = mean + se, fill = sample),
                                 color = NA, alpha = 0.20)
    }
    
    plot <- plot + geom_vline(data = linered, aes(xintercept = line), linetype = 1, color = "red") +
      theme_bw(base_size = 30) +
      theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
            axis.title.x = element_blank(), panel.grid.minor.y = element_blank()) +
      facet_grid(. ~ reg, scales = "free", switch = "x") +
      theme(strip.background = element_blank(), strip.placement = "outside") +
      geom_vline(data = lines3nt, aes(xintercept = line), linetype = 3, color = "gray60")
    
    if(!is.null(colour)){
      plot <- plot + scale_fill_manual(labels = names(sample_l), values = as.character(colour), guide = 'none') +
        scale_color_manual(labels = names(sample_l), values = as.character(colour))
    } else {
      plot <- plot + guides(fill = FALSE)
    }
    
    if(plot_style == "mirrored"){
      plot <- plot + scale_y_continuous(labels = abs)
    }
    
    if(length(col_plot_sel) > 1 & plot_style != "split"){
      plot <- plot + theme(legend.position = c(0.98,1), legend.justification = c(1, 1),
                           legend.title = element_blank(), legend.background = element_blank())
    } else {
      plot <- plot + theme(legend.position = "none")
    }
    
    if(plot_style == "split"){
      plot <- plot + facet_grid(sample ~ reg, scales = "free", switch = "x") +
        theme(strip.background = element_blank(), strip.placement = "outside")
    }
    
    if(frequency != TRUE){
      plot <- plot + labs(y = "P-site")
    } else {
      plot <- plot + labs(y = "P-site frequency")
    }
    
    if(length(plot_title) != 0) {
      if(length(setdiff(plot_title_v, c("sample", "transcript", "length_range"))) == 0 &
         length(plot_title_v) != 0){
        plottitle <- f_title_plot(plot_title_v = plot_title_v, multisamples = multisamples,
                                  sample_l = sample_l, data = data, samp = NULL, ntr = ntr,
                                  length_range = length_range, length_common = length_common)
        plot <- plot + labs(title = plottitle) +
          theme(plot.title = element_text(hjust = 0.5))
      } else {
        if(length(plot_title) != 0){
          plot <- plot + labs(title = plot_title) +
            theme(plot.title = element_text(hjust = 0.5))
        }
      }
    }
    
    output[["plot"]] <- plot
    
  } else {
    if(!is.null(colour)){
      colour = colour[1]
    } else {
      colour = "gray40"
    }
    
    for(col_plot in as.character(unlist(col_plot_sel))){
      plot <- ggplot(final_dt, aes_string("distance", col_plot)) +
        geom_line(size = 1.50, color = as.character(colour)) +
        geom_vline(data = linered, aes(xintercept = line), linetype = 1, color = "red") +
        theme_bw(base_size = 30) +
        theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
              axis.title.x = element_blank(), panel.grid.minor.y = element_blank()) +
        facet_grid(. ~ reg, scales = "free", switch = "x") +
        theme(strip.background = element_blank(), strip.placement = "outside") +
        geom_vline(data = lines3nt, aes(xintercept = line), linetype = 3, color = "gray60")
      
      if(frequency != TRUE){
        plot <- plot + labs(y = "P-site")
      } else {
        plot <- plot + labs(y = "P-site frequency")
      }
      
      if(length(plot_title) != 0) {
        if(length(setdiff(plot_title_v, c("sample", "transcript", "length_range"))) == 0 &
           length(plot_title_v) != 0){
          plottitle <- f_title_plot(plot_title_v = plot_title_v, multisamples = multisamples, 
                                    sample_l = sample_l, data = data, samp = col_plot, ntr = ntr,
                                    length_range = length_range, length_common = length_common)
          plot <- plot + labs(title = plottitle) +
            theme(plot.title = element_text(hjust = 0.5))
        } else {
          if(length(plot_title) != 0){
            plot <- plot + labs(title = plot_title) +
              theme(plot.title = element_text(hjust = 0.5))
          }
        }
      }
      
      output[[paste0("plot_", col_plot)]] <- plot
    }
  }
  
  if(is.list(sample) & length(as.character(unlist(sample))) == length(sample) &
     length(sample) > 1 & multisamples != "separated"){
    setnames(output[["dt"]], old = as.character(unlist(sample)), new = names(sample))
  }
  
  return(output)
}

f_title_plot <- function(plot_title_v, multisamples, sample_l, data, samp, ntr,
                          length_range, length_common){
  
  if("sample" %in% plot_title_v & length(sample_l) == 1){
    if(multisamples %in% c("average", "sum")){
      t_sample <- paste0("Samples: ", paste(as.character(unlist(sample_l)), collapse = ", "))
    } else {
      t_sample <- paste0("Sample: ", samp) 
    }
  }
  
  if("transcript" %in% plot_title_v){
    t_transcript <- paste0(ntr, " transcripts")
  }
  
  if("length_range" %in% plot_title_v){
    if(multisamples %in% c("average", "sum")){
      if(!identical(length_range, "all")){
        length_range_pl <- sort(intersect(length_common, length_range))
      } else {
        length_range_pl <- sort(length_common)
      }
    } else {
      length_sample <- data[[samp]]$length
      lmin_temp <- quantile(length_sample, 0.05)
      lmax_temp <- quantile(length_sample, 0.95)
      length_sample <- unique(length_sample[length_sample %between% c(lmin_temp, lmax_temp)])
      
      if(!identical(length_range, "all")){
        length_range_pl <- sort(intersect(length_sample, length_range))
      } else {
        length_range_pl <- sort(length_sample)
      }
    }
    
    minlr <- min(length_range_pl)
    maxlr <- max(length_range_pl)
    
    if(minlr == maxlr) {
      t_length_range <- paste0("Read length: ", min(length_range_pl), " nts")
    } else {
      if(identical(length_range_pl, minlr:maxlr) | identical(length_range_pl, seq(minlr, maxlr, 1))){
        t_length_range <- paste0("Read lengths: ", minlr, "-", maxlr, " nts")
      } else {
        nextl <- sort(unique(length_range_pl[c(which(diff(length_range_pl) != 1), which(diff(length_range_pl) != 1) + 1)]))
        sep <- ifelse(nextl %in% length_range_pl[which(diff(length_range_pl) != 1)], ",", "-")[-length(nextl)]
        if(1 %in% which(diff(length_range_pl) == 1)){
          nextl <- c(length_range_pl[1], nextl)
          sep <- c("-", sep)
        }
        if((length(length_range_pl) - 1) %in% which(diff(length_range_pl) == 1)){
          nextl <- c(nextl, length_range_pl[length(length_range_pl)])
          sep <- c(sep, "-")
        }
        sep <- c(sep, "")
        t_length_range <- paste0("Read lengths: ", paste0(nextl, sep, collapse = ""), " nts")
      }
    }
  }
  
  plottitle <- paste(unlist(mget(paste0("t_", plot_title_v))), collapse = "; ")
  return(plottitle)
}

#' Ribosome occupancy metaheatmaps at single-nucleotide resolution.
#'
#' This function generates two heatmap-like metaprofiles (metaheatmaps)
#' displaying the abundance of P-sites around the start and the stop codon of
#' annotated CDSs. It works similarly to \code{\link{metaprofile_psite}} but the
#' intensity of signal is represented by a continuous color scale rather than by
#' the height of a line chart. This graphical output is a good option to
#' visualize several profiles at once and compare results obtained with
#' different read lengths or in multiple conditions.
#'
#' @param data List of data tables from \code{\link{psite_info}}.
#' @param annotation Data table as generated by \code{\link{create_annotation}}.
#' @param sample List of either character strings specifying the name of the
#'   sample(s) of interest or character string vectors specifying the name of
#'   their replicates. In the latter case the final metaheatmap for each
#'   element of the list is generated by merging the corresponding replicates
#'   exploiting the scale factors specified by \code{scale_factors}. The row(s)
#'   of the final plot are labelled according to the name of the elements of the
#'   list.
#' @param scale_factors Named numeric vector specifying the scale factors for
#'   generating metaprofiles from multiple replicates (see \code{sample}). Scale
#'   factors can be defined for a subset of list elements of \code{sample} i.e.
#'   for all replicates of selected samples. If so, the remaining scale factors
#'   are set automatically to 1. Please be careful to name each element of the
#'   vector after the correct corresponding string in \code{sample}. No specific
#'   order is required. Default is NULL i.e. all scale factors are automatically
#'   set to 1.
#' @param length_range Integer or an integer vector specyfying the read
#'   length(s) to be included in the analysis. Default is "all" i.e. all read
#'   lengths are used.
#' @param transcripts Character string vector listing the name of transcripts to
#'   be included in the analysis. Default is NULL i.e. all transcripts are used.
#'   Please note: transcripts with either 5' UTR, coding sequence or 3' UTR
#'   shorter than \code{utr5l}, \eqn{2*}\code{cdsl} and \code{utr3l},
#'   respectively, are automatically discarded.
#' @param utr5l Positive integer specifying the length (in nucleotides) of the
#'   5' UTR region flanking the start codon to be considered in the analysis.
#'   Default is 25.
#' @param cdsl Positive integer specifying the length (in nucleotides) of the
#'   CDS regions flanking both the start and stop codon to be considered in the
#'   analysis. Default is 50.
#' @param utr3l Positive integer specifying the length (in nucleotides) of the
#'   3' UTR region flanking the stop codon to be considered in the analysis.
#'   Default is 25.
#' @param colour Character string specifying the colour of the plot. The colour
#'   scheme is as follow: tiles corresponding to the lowest signal are always
#'   white, tiles corresponding to the highest signal are of the specified
#'   colour and the progression between these two colours follows either linear
#'   or logarithmic gradients (see \code{log_colour}). Default is "black".
#' @param log_colour Logical value whether to use a logarithmic colour scale
#'   (strongly suggested in case of large signal variations). Default is FALSE.
#' @param plot_title Character string specifying the title of the plot. If
#'   "auto", the title of the plot reports the number of transcripts and the
#'   read length(s) employed for generating the metaprofiles. Default is NULL
#'   i.e. no title is displayed.
#' @details The intensity of signal in the metaprofiles corresponds, for each
#'   nucleotide, to the sum of the number of P-sites (defined by their leftmost
#'   position) mapping on that position for all transcripts in one or multiple
#'   replicates.
#' @return A list containing a ggplot2 object ("plot") and the data table
#'   with the associated data ("dt").
#' @examples
#' ## data(reads_list)
#' ## data(mm81cdna)
#' ##
#' ## ## compute and add p-site datails
#' ## psite_offset <- psite(reads_list, flanking = 6, extremity = "auto")
#' ## reads_psite_list <- psite_info(reads_list, psite_offset)
#' ##
#' ## ## Generate metaheatmaps employing all read lengths:
#' ## metaheat_whole <- metaheatmap_psite(reads_psite_list, mm81cdna,
#' ##                                     sample = list("Whole"=c("Samp1")))
#' ##
#' ## ## Generate metaprofiles employing reads of 27, 28 and 29 nucleotides and
#' ## ## a subset of transcripts (in this example only transcripts with at least
#' ## ## one P-site mapping on the translation initiation site are kept):
#' ## sample_name <- "Samp1"
#' ## sub_reads_psite_list <- reads_psite_list[[sample_name]][psite_from_start == 0]
#' ## transcript_names <- as.character(sub_reads_psite_list$transcript)
#' ## metaheat_sub <- metaheatmap_psite(reads_psite_list, mm81cdna,
#' ##                                   sample = list("sub"=sample_name),
#' ## length_range = 27:29, transcripts = transcript_names, plot_title = "auto")
#' ##
#' ## ## Generate two sets of metaheatmaps, displayed in the same plot. In this
#' ## ## example one set of metaheatmaps is based on all read lengths while the
#' ## ## other one is generated employing only reads of 28 nucleotides:
#' ## sample_name <- "Samp1"
#' ## metaheat_df <- list()
#' ## metaheat_df[["subsample_28nt"]] <- reads_psite_list[[sample_name]][length == 28]
#' ## metaheat_df[["whole_sample"]] <- reads_psite_list[[sample_name]]
#' ## sample_list <- list("Only_28" = c("subsample_28nt"),
#' ##                     "All" = c("whole_sample"))
#' ## metaheat_comparison <- metaheatmap_psite(metaheat_df, mm81cdna,
#' ##                                          sample = sample_list)
#' @import data.table
#' @import ggplot2
#' @export
metaheatmap_psite <- function(data, annotation, sample, scale_factors = NULL,
                              length_range = "all", transcripts = NULL,
                              utr5l = 25, cdsl = 50, utr3l = 25, log_colour = F,
                              colour = "black", plot_title = NULL) {
  
  check_sample <- setdiff(unlist(sample), names(data))
  if(length(check_sample) != 0){
    cat("\n")
    stop(sprintf("incorrect sample name(s): \"%s\" not found\n\n",
                 paste(check_sample, collapse = ", ")))
  }
  
  if(length(scale_factors) != 0) {
    if(!all(unlist(sample) %in% names(scale_factors))){
      cat("\n")
      stop("scale factor for one or more replicates is missing\n\n")
    }
  }
  
  if(!identical(length_range, "all") & !inherits(length_range, "numeric") & !inherits(length_range, "integer")){
    cat("\n")
    warning("class of length_range is neither numeric nor integer. Set to default \"all\"\n", call. = FALSE)
    length_range = "all"
  }
  
  if(!identical(length_range, "all")){
    if(is.list(sample)){
      for(sampgroup in names(sample)){
        for(samp in sample[[sampgroup]]){
          len_check <- unique(data[[samp]]$length)
          if(!(any(length_range %in% len_check))) {
            cat("\n")
            warning(sprintf("\"%s\" doesn't contain any reads of the specified lengths: sample removed\n", samp), call. = FALSE)
            sample[[sampgroup]] <- sample[[sampgroup]][sample[[sampgroup]] != samp]
          }
        }
        if(length(sample[[sampgroup]]) == 0) {
          cat("\n")
          warning(sprintf("none of the data tables in \"%s\" contain reads of the specified lengths: group of samples removed \n", sampgroup), call. = FALSE)
          sample[[sampgroup]] <- NULL
        }
      }
    } else {
      for(samp in sample){
        len_check <- unique(data[[samp]]$length)
        if(!(any(length_range %in% len_check))) {
          cat("\n")
          warning(sprintf("\"%s\" doesn't contain any reads of the specified lengths: sample removed\n", samp), call. = FALSE)
          sample <- sample[sample != samp]
        }
      }
    }
  }

  
  if(length(sample) == 0){
    cat("\n")
    stop("none of the data tables in sample contains any reads of the specified lengths\n\n")
  }
  
  l_transcripts <- as.character(annotation[l_utr5 >= utr5l & 
                                             l_cds >= 2 * (cdsl + 1) &
                                             l_utr3 >= utr3l, transcript])
  
  if (length(transcripts) == 0) {
    c_transcripts <- l_transcripts
    ntr <- length(c_transcripts)
  } else {
    c_transcripts <- intersect(l_transcripts, transcripts)
    ntr <- length(transcripts)
  }
  
  length_temp <- vector()
  
  for(sampgroup in names(sample)){
    for(samp in sample[[sampgroup]]) {
      
      dt <- data[[samp]][as.character(transcript) %in% c_transcripts]
      
      if (identical(length_range, "all")) {
        start_sub <- dt[psite_from_start %in% seq(-utr5l, cdsl)]
        stop_sub <- dt[psite_from_stop %in% seq(-cdsl, utr3l)]
      } else {
        start_sub <- dt[psite_from_start %in% seq(-utr5l, cdsl) & length %in% length_range]
        stop_sub <- dt[psite_from_stop %in% seq(-cdsl, utr3l) & length %in% length_range]
      }
      
      setkey(start_sub, psite_from_start)
      start_tab <- start_sub[CJ(-utr5l:cdsl), list(reads = .N), by = list(distance = psite_from_start)
                             ][, reg := "start"]
      setkey(stop_sub, psite_from_stop)
      stop_tab <- stop_sub[CJ(-cdsl:utr3l), list(reads = .N), by = list(distance = psite_from_stop)
                           ][, reg := "stop"]
      samp_tab <- rbind(start_tab, stop_tab)
      
      if(samp %in% names(scale_factors)) {
        samp_tab[, reads := reads * scale_factors[samp]]
      }
      
      if(exists("temp_tab_heatmap")) {
        temp_tab_heatmap[, reads := reads + samp_tab$reads]
      } else {
        temp_tab_heatmap <- samp_tab
      }
      temp_tab_heatmap[, sample := sampgroup]
      
      length_temp <- unique(c(length_temp, data[[samp]]$length))
    }
    
    if(exists("final_tab_heatmap")) {
      final_tab_heatmap <- rbind(final_tab_heatmap, temp_tab_heatmap)
    } else {
      final_tab_heatmap <- temp_tab_heatmap
    }
    rm(temp_tab_heatmap)
  }
  
  if(!identical(length_range, "all")){
    length_range <- sort(intersect(length_temp, length_range))
  } else {
    length_range <- sort(length_temp)
  }
  
  final_tab_heatmap[, reg := factor(reg, levels = c("start", "stop"), labels = c("Distance from start (nt)", "Distance from stop (nt)"))
                    ][, sample := factor(sample, levels = rev(unique(final_tab_heatmap$sample)))]
  
  lines3nt <- data.table(reg = rep(c("Distance from start (nt)", "Distance from stop (nt)"), times = c(length(seq(3, cdsl, 3)), length(seq(-2, -cdsl, -3)))), line = c(seq(3, cdsl, 3), rev(seq(-2, -cdsl, -3))))
  linered <- data.frame(reg = c("Distance from start (nt)", "Distance from stop (nt)"), line =c(0, 1))
  
  maxl <- max(final_tab_heatmap$reads)
  
  plot <- ggplot(final_tab_heatmap, aes(as.numeric(as.character(distance)), sample)) +
    geom_vline(data = lines3nt, aes(xintercept = line), linetype = 3, color = "gray60") +
    geom_vline(data = linered, aes(xintercept = line), linetype = 1, color = "red") +
    geom_tile(aes(fill = reads), height = 0.7) +
    labs(title = plot_title) +
    theme_bw(base_size = 25) +
    theme(panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(),
          panel.grid.major.y = element_blank(), strip.placement = "outside",
          axis.title.x = element_blank(), axis.title.y = element_blank()) +
    facet_grid(. ~ reg, scales = "free", switch = "x") +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(strip.background = element_blank())
  
  if(log_colour == F) {
    minl <- min(final_tab_heatmap$reads)
    plot <- plot +
      scale_fill_gradient("P-site signal\n", low = "white", high = colour, na.value = "white",
                          limits = c(minl, maxl),
                          breaks = c(minl, minl/2 + maxl/2, maxl),
                          labels = c(round(minl, 2), round(minl/2 + maxl/2, 2), round(maxl, 2)))
  } else {
    minl <- min(final_tab_heatmap[reads != 0, reads])
    plot <- plot +
      scale_fill_gradient("P-site signal\n", low = "white", high = colour, trans = "log", na.value = "transparent",
                          limits = c(minl, maxl),
                          breaks = c(minl, 10^(log10(minl)/2 + log10(maxl)/2), maxl),
                          labels = c(round(minl, 2), round(10^(log10(minl)/2 + log10(maxl)/2), 2), round(maxl, 2)))
  }
  
  if(identical(plot_title, "auto")) {
    
    title1 <- paste0(ntr, " tr. Read length: ")
    minlr <- min(length_range)
    maxlr <- max(length_range)
    
    if(minlr == maxlr) {
      plottitle <- paste0(title1, min(length_range), " nts")
    } else {
      if(identical(length_range, minlr:maxlr) | identical(length_range, seq(minlr, maxlr, 1))){
        plottitle <- paste0(title1, minlr, "-", maxlr, " nts")
      } else {
        nextl <- sort(length_range[c(which(diff(length_range) != 1), which(diff(length_range) != 1) + 1)])
        sep <- ifelse(nextl %in% length_range[which(diff(length_range) != 1)], ", ", "-")[-length(nextl)]
        if(1 %in% which(diff(length_range) == 1)){
          nextl <- c( length_range[1], nextl)
          sep <- c("-", sep)
        }
        if((length(length_range) - 1) %in% which(diff(length_range) == 1)){
          nextl <- c(nextl, length_range[length(length_range)])
          sep <- c(sep, "-")
        }
        sep <- c(sep, "")
        plottitle <- paste0(title1, paste0(nextl, sep, collapse = ""), " nts")
      }
    }
    plot <- plot +
      labs(title = plottitle) +
      theme(plot.title = element_text(hjust = 0.5))
  } else {
    if(length(plot_title) != 0){
      plot <- plot +
        labs(title = plot_title) + 
        theme(plot.title = element_text(hjust = 0.5))
    }
  }
  
  output <- list()
  output[["plot"]] <- plot
  output[["dt"]] <- final_tab_heatmap
  return(output)
}
