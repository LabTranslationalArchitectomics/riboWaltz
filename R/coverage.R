#' Compute the number of reads per codon.
#'
#' For the specified sample(s), this function computes the codon coverage
#' defined either as the number of read footprints per codon or as the number of
#' P-sites per codon.
#'
#' @param data A list of data tables from \code{\link{psite_info}}. Data tables
#'   generated by \code{\link{bamtolist}} and \code{\link{bedtolist}} can be
#'   used only if \code{psite} is FALSE (the default).
#' @param annotation A data table as generated by
#'   \code{\link{create_annotation}}.
#' @param sample A character string vector specifying the name of the sample(s)
#'   of interest. By default this argument is NULL, meaning that the coverage is
#'   computed for all the samples in \code{data}.
#' @param psite A logical value whether or not to return the number of P-sites
#'   per codon. Default is NULL, meaning that the number of read footprints per
#'   codon is computed instead.
#' @param min_overlap A positive integer specyfing the minimum number of
#'   overlapping positions (in nucleotides) between a reads and a codon to be
#'   considered to be overlapping. When \code{psite} is TRUE this parameter must
#'   be 1 (the default).
#' @param granges A logical value whether or not to return a GRanges object.
#'   Default is FALSE, meaning that a data tables is returned instead.
#' @details The sequence of every transcript is divided in triplets starting
#'   from the annotated translation initiation site (if any) proceeding towards
#'   the UTRs extremities, and eventually discarding the exceeding 1 or 2
#'   nucleotides at the extremities of the transcript. Please note that the
#'   transcripts not associated to any annotated \emph{5' UTR}, \emph{CDS} and
#'   \emph{3'UTR} and transcripts with coding sequence length not divisible by 3
#'   are automatically discarded.
#' @return A data table or a GRanges object.
#' @examples
#' data(reads_psite_list)
#' data(mm81cdna)
#'
#' ## Compute the coverage based on the number of ribosome footprint per codon,
#' ## setting the minimum overlap between reads and triplets to 3 nts
#' ## coverage_dt <- codon_coverage(reads_psite_list, mm81cdna, min_overlap = 3)
#'
#' ## Compute the coverage based on the number of P-sites per codon
#' ##coverage_dt <- codon_coverage(reads_psite_list, mm81cdna, psite = TRUE)
#' @import data.table
#' @export
codon_coverage <- function(data, annotation, sample = NULL, psite = FALSE,
                           min_overlap = 1, granges = FALSE) {
  
  if((psite == TRUE || psite == T) & min_overlap != 1){
    cat("\n")
    stop("invalid value for min_over when psite is TRUE\n\n")
  }
  
  if(length(sample) == 0){
    sample <- names(data)
  }
  
  bin <- 3
  
  cat("1. creating codon table and computing distance from start/stop codon\n")
  
  l_transcripts <- as.character(annotation[l_utr5 > 0 & 
                                             l_cds > 0 &
                                             l_cds %% 3 == 0 &
                                             l_utr3 > 0, transcript])
  
  bin_coverage_tab <- annotation[as.character(transcript) %in% l_transcripts
                                 ][order(transcript)
                                   ][, transcript := factor(transcript, levels = transcript)
                                     ][, start := l_utr5 %% bin
                                       ][, l_utr5 := l_utr5 - (l_utr5 %% bin)
                                         ][, l_cds := l_cds - (l_cds %% bin)
                                           ][, l_utr3 := l_utr3 - (l_utr3 %% bin)
                                             ][, len := l_utr5 + l_cds + l_utr3
                                               ][, list(start = seq(from = start, to = start + len - bin, by = bin),
                                                        end = seq(from = start, to = start + len - bin, by = bin) + bin,
                                                        start_dist = (seq(from = start, to = start + len - bin, by = bin) - (start + l_utr5)) / bin,
                                                        stop_dist = (seq(from = start, to = start + len - bin, by = bin) - (start + l_utr5 + l_cds - bin)) / bin),
                                                        by = transcript
                                                 ]
  
  gr_interval <- GenomicRanges::GRanges(seqnames = bin_coverage_tab$transcript,
                                        IRanges(bin_coverage_tab$start + 1,  width = bin),
                                        strand = "+")
  
  cat("2. acquiring region information\n")
  bin_coverage_tab[, region := "5utr"
                   ][start_dist >= 0 & stop_dist <= 0, region := "cds"
                     ][stop_dist > 0, region := "3utr"]

  if(psite == T || psite == TRUE){
    cat("3. computing codon coverage based on P-site\n")
  } else {
    cat("3. computing codon coverage based on read footprints\n")
  }
  
  for(samp in sample){
    cat(sprintf("sample : %s\n", samp))
    
    dt <- data[[samp]][as.character(transcript) %in% levels(bin_coverage_tab$transcript)
                       ][, transcript := factor(transcript, levels = levels(bin_coverage_tab$transcript))]

    if(psite == T || psite == TRUE){
      gr_read <- GenomicRanges::GRanges(seqnames = dt$transcript,
                                        IRanges(dt$psite, dt$psite),
                                        strand="+")
    } else {
      gr_read <- GenomicRanges::GRanges(seqnames = dt$transcript,
                                        IRanges(dt$end5, dt$end3),
                                        strand="+")
    }
    
    bin_coverage_tab[, (samp) := GenomicRanges::countOverlaps(gr_interval, gr_read, minoverlap = min_overlap)]
  }
  
  if (granges == T || granges == TRUE) {
    bin_coverage_tab <- GenomicRanges::makeGRangesFromDataFrame(bin_coverage_tab,
                                                                keep.extra.columns = TRUE,
                                                                ignore.strand = TRUE,
                                                                seqnames.field = c("transcript"),
                                                                start.field = "end5",
                                                                end.field = "end3",
                                                                strand.field = "strand",
                                                                starts.in.df.are.0based = FALSE)
    GenomicRanges::strand(bin_coverage_tab) <- "+"
  }
  
  return(bin_coverage_tab)
}
